name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
  workflow_dispatch:

jobs:
  deploy-and-dast:
    name: Deploy to K8s & DAST Scan
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # STAGE 1: Deploy to Kubernetes (Simulated)
      # In a real scenario, you would use actions/k8s-set-context or azure/k8s-deploy
      - name: Simulate K8s Deployment
        run: |
          echo "Connecting to Kubernetes Cluster..."
          echo "Applying manifest deployment.yaml..."
          cat deployment.yaml
          echo "Deployment successful! Pods are running."

      # STAGE 2: Run Application for DAST
      # We pull the image and run it locally to simulate the 'live' app for scanning
      - name: Run App for DAST
        run: |
          docker run -d -p 8080:8080 --name dast-target ${{ secrets.DOCKERHUB_USERNAME }}/devops-project:latest
          sleep 10

      # STAGE 3: DAST Scan (OWASP ZAP)
      # Scans the running application for vulnerabilities
      - name: ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.11.0
        with:
          target: 'http://localhost:8080'
          fail_action: false # Don't fail the build for existing alerts (Assignment asks for dummy)
          allow_issue_writing: false

      - name: Teardown
        if: always()
        run: docker stop dast-target
