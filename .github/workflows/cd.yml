name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
  workflow_dispatch:

jobs:
  deploy-and-dast:
    name: Deploy to K8s & DAST Scan
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # STAGE 1: Deploy to Kubernetes (Simulated)
      # In a real scenario, you would use actions/k8s-set-context or azure/k8s-deploy
      - name: Simulate K8s Deployment
        run: |
          echo "Connecting to Kubernetes Cluster..."
          echo "Applying manifest deployment.yaml..."
          cat deployment.yaml
          echo "Deployment successful! Pods are running."

      # STAGE 2: Run Application for DAST
      # We verify the image exists first.
      # using --network host is the most reliable way for one container to call another on GitHub Actions.
      - name: Run App for DAST
        run: |
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/devops-project:latest
          docker run -d --network host --name dast-target ${{ secrets.DOCKERHUB_USERNAME }}/devops-project:latest
          echo "Waiting for application to start..."
          sleep 30

      # STAGE 3: DAST Scan (OWASP ZAP)
      # Scans the running application for vulnerabilities
      - name: ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.11.0
        continue-on-error: true
        with:
          target: 'http://localhost:8080'
          artifact_name: 'dast-report'
          fail_action: false 
          allow_issue_writing: false

      - name: Teardown
        if: always()
        run: docker stop dast-target
